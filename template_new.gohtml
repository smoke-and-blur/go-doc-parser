<!DOCTYPE html>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1" />

<script src="erg0.js"></script>

<style>
    table * {
        border: 1px solid #888;
    }

    table,
    td {
        width: 100%;
    }

    table {
        border-collapse: collapse;
        border-spacing: 0;
    }

    th {
        background: #eee;
    }

    * {
        font-size: 16px;
        box-sizing: border-box;
        margin: 0;
    }

    .divider {
        padding: 3px;
        grid-column: span 4;
        border-radius: 6px;
        background: #eee;
        text-align: center;
        color: #666;
        font-weight: bold;
    }

    #container {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-width: 720px;
        align-items: center;
        justify-content: center;
        padding: 16px;
    }

    .matrix {
        display: grid;
        gap: 16px;
        grid-template-columns: 1fr 1fr;
    }

    #container>* {
        width: 100%;
    }

    body {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .number {
        text-align: right;
    }

    .header {
        font-weight: bold;
        font-size: 18px;
        text-wrap: wrap;
        max-width: 24ch;
        overflow-wrap: anywhere;
        text-align: center;
    }

    .options {
        display: flex;
        flex-direction: row;
        gap: 16px;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    button {
        border-radius: 6px;
        border: 1px solid #eee;
        background: none;
        padding: 6px;
    }

    button:hover {
        cursor: pointer;
        background: #eee;
    }

    .table {
        align-content: start;
        display: grid;
        grid-template-columns: max-content 5fr 5fr 1fr;
        gap: 6px;
        border: 1px solid #eee;
        border-radius: 12px;
        padding: 6px;
    }

    input[type="checkbox"] {
        width: 24px;
        height: 24px;
    }
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>

<script>

    const { render, notify, tags, props, events } = erg0
    const { p, div, pre, button, textarea, img, input, span } = tags
    const { id, rows, value, type, className, style, src, draggable, checked } = props
    const { onclick, onchange, ondragstart, ondragenter, ondragover, ondragleave, ondrop } = events

    let data = {{.}}

    data.Pages.sort((a, b) => a.Filename.localeCompare(b.Filename))

    data.Pages[0].cutoff = 18

    document.addEventListener(
        "DOMContentLoaded",
        function () {
            const app = document.getElementById('app')

            render(Data, app)
        }
    )

    function Data() {
        return div(id`container`,
            img(
                style`width: 36px; height: 36px`,
                src`https://upload.wikimedia.org/wikipedia/commons/8/8d/Emblem_of_the_State_Border_Guard_Service_of_Ukraine.svg`,
            ),
            ...aggregate(),
            textarea(
                id`summary`,
                rows`12`,
                style`border-radius: 12px; border: 1px solid #eee; padding: 6px;`,
                `summary`
            ),
            div(className`options`,
                button("Скопіювати",
                    onclick(e => {
                        navigator.clipboard.writeText(document.getElementById('summary').value)
                        alert('Скопійовано!')
                    }, !notify)
                ),
                button("Поділитися",
                    onclick(e => {
                        navigator.share({ text: document.getElementById('summary').value })
                    }, !notify)
                ),
            ),
        )
    }

    function Header(page) {
        return [
            div(className`header`, page.Filename),
            div(
                className`options`,
                style`gap: 4px`,
                input(type`checkbox`, page.cutoff === 18 ? checked`` : null, onchange(e => page.cutoff = e.target.checked ? 18 : 0)),
                p("18:00-00:00"),
            ),
        ]
    }

    function Group(page, group, sum) {
        let out = []

        const cells = [
            { value: group.Type, span: 1 },
            { value: group.Name, span: 1 },
            { value: group.Hint, span: 1 },
        ]

        calculateSpans(cells)

        for (const component of cells) {
            component.value && out.push(
                div(
                    style`grid-column: span ${component.span};`,
                    component.value,
                )
            )
        }

        out.push(div(className`number`, sum))

        return out
    }

    function Divider(text) {
        return div(className`divider`, text)
    }

    function Number(n) {
        return div(
            className`number`,
            style`grid-column: span 4; font-weight:bold`,
            n,
        )
    }

    function Table(elements) {
        return div(className`table`, ...elements)
    }

    function Matrix(elements) {
        return div(className`matrix`, ...elements)
    }

    class EasyMap extends Map {
        normalizeKey(key) {
            if (typeof key === "object" && key !== null) {
                return JSON.stringify(key, Object.keys(key).sort()); // stable order
            }
            return key;
        }

        push(key, value) {
            const k = this.normalizeKey(key);
            if (!this.has(k)) this.set(k, []);
            this.get(k).push(...value);
        }

        increment(key, delta = 1) {
            this.set(k, (this.getKey(k) ?? 0) + delta);
        }

        getKey(key) {
            return this.get(this.normalizeKey(key));
        }
    }

    function Action() {
        return div(
            style`cursor:pointer; display: inline-block; background: #eee; border: 1px solid #ddd; padding: 0 6px; border-radius: 8px;`,
            ...arguments,
        )
    }

    function tokenize(str) {
        const re = /(\d+)\s*гр./g;
        const tokens = [];
        let lastIndex = 0;

        for (const m of str.matchAll(re)) {
            // push text before match
            if (m.index > lastIndex) {
                tokens.push({ type: "text", value: str.slice(lastIndex, m.index) });
            }

            // push the match itself
            tokens.push({
                type: "pieces",
                value: m[0],   // e.g. "123 pieces"
                number: m[1]  // just "123"
            });

            lastIndex = m.index + m[0].length;
        }

        // push any trailing text
        if (lastIndex < str.length) {
            tokens.push({ type: "text", value: str.slice(lastIndex) });
        }

        return tokens.map(t => t.type === "text" ? t.value : span(style`background:#eaa;border: 1px solid #d33; border-radius: 6px; padding: 0 6px`, t.value))
    }

    function Comment(key, comments) {
        key = JSON.parse(key)
        return [
            Divider([key.Type, key.Name, key.Hint].filter(Boolean).join(" • ")),
            ...comments.map(
                comment => div(
                    style`grid-column: span 4; white-space: pre; text-wrap: wrap; overflow-wrap: break-word;`,
                    ...tokenize(comment.Comment),
                    Action("→0", onclick(e => console.log(e.target))),
                ),
            ),
        ]
    }

    function aggregate() {
        aggregateSelected = new EasyMap();
        aggregateOther = new EasyMap();
        aggregateComments = new EasyMap();

        let out = []

        for (const page of data.Pages) {
            page.cutoff ??= 0

            out.push(...Header(page))

            var total = 0

            toplevel = []

            for (const selectedSupergroup of page.SelectedSupergroups) {
                items = [Divider(selectedSupergroup[0].Name)]

                let total = 0

                for (const group of selectedSupergroup) {
                    // count function to reuse???
                    let filtered = group.Events.filter(e => e.End >= page.cutoff)

                    let key = { Name: selectedSupergroup[0].Name }

                    aggregateSelected.push(key, filtered)

                    // TODO: single reduce call aggregating events+comments???
                    let comments = filtered.filter(e => e.Comment);

                    comments.length > 0 && aggregateComments.push(key, comments)

                    let sum = filtered.length

                    total += sum

                    items.push(...Group(page, group, sum))
                }

                items.push(Number(total))


                toplevel.push(Table(items))
            }

            toplevel = [Matrix(toplevel)]

            other = [Divider("Інші")]

            for (const group of page.OtherGroups) {
                let k = { Type: group.Type, Name: group.Name, Hint: group.Hint }

                let filtered = group.Events.filter(e => e.End >= page.cutoff)

                aggregateOther.push(k, filtered)

                let comments = filtered.filter(e => e.Comment);

                comments.length > 0 && aggregateComments.push(k, comments)

                other.push(...Group(page, group, filtered.length))
            }

            toplevel.push(Table(other))

            out.push(toplevel)
        }

        out.push(div(className`header`, "Підсумок"))

        selected = [Divider("Сума за всі документи")]

        aggregateSelected.forEach((events, k) => {
            selected.push(...Group({ cutoff: 0 }, { Name: JSON.parse(k).Name }, events.length))
        })

        out.push(Table(selected))

        out.push(div(className`header`, "Примітки"))

        aggregateComments.forEach((c, key) => {
            out.push(Table(Comment(key, c)))
        })

        return out
    }

    function calculateSpans(items) {
        let last = -1
        let span = 0

        for (let i = 0; i < items.length + 1; i++) {
            if (items[last] && items[last].value) {
                items[last].span += span
                span = 0
            }

            if (items[i] && items[i].value) {
                last = i
                continue
            }

            // only count spans if there is an empty cell
            span++
        }
    }

</script>

<div id="app">

</div>