<!DOCTYPE html>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1" />

<script>
    (function (global) {
        class VNode {
            constructor(tag, props = {}, children = []) {
                this.tag = tag;
                this.props = props;
                this.children = children.flat();
                this.el = null;
            }

            node() {
                const el = document.createElement(this.tag);
                this.el = el;

                for (let [k, v] of Object.entries(this.props)) {
                    if (k.startsWith("on") && typeof v === "function") {
                        el[k.toLowerCase()] = v;
                        continue;
                    }
                    if (k === "className") {
                        el.setAttribute("class", v);
                        continue;
                    }
                    if (v === true) {
                        el.setAttribute(k, "");
                        continue;
                    }
                    if (v !== false && v != null) {
                        el[k] = v;
                    }
                }

                for (let c of this.children) {
                    if (c == null) continue;
                    el.appendChild(c.node());
                }

                return el;
            }
        }

        class TextVNode extends VNode {
            constructor(text) {
                super(null);
                this.text = String(text);
            }
            node() {
                this.el = document.createTextNode(this.text);
                return this.el;
            }
        }

        function patchChildren(parent, oldChildren, newChildren) {
            const len = Math.max(oldChildren.length, newChildren.length);

            for (let i = 0; i < len; i++) {
                const oldC = oldChildren[i];
                const newC = newChildren[i];

                if (!oldC && newC) {
                    parent.appendChild(newC.node());
                    continue;
                }

                if (oldC && !newC) {
                    parent.removeChild(oldC.el);
                    continue;
                }

                if (oldC instanceof TextVNode && newC instanceof TextVNode) {
                    if (oldC.text !== newC.text) {
                        oldC.el.nodeValue = newC.text;
                    }
                    newC.el = oldC.el;
                    continue;
                }

                if (oldC instanceof VNode && newC instanceof VNode) {
                    patch(oldC, newC, parent);
                }
            }
        }

        function patch(oldVNode, newVNode, parent) {
            if (oldVNode.tag !== newVNode.tag) {
                parent.replaceChild(newVNode.node(), oldVNode.el);
                return;
            }

            const el = (newVNode.el = oldVNode.el);

            // remove old props
            for (let k in oldVNode.props) {
                if (!(k in newVNode.props)) {
                    if (k.startsWith("on")) {
                        el[k.toLowerCase()] = null;
                    } else if (k === "className") {
                        el.removeAttribute("class");
                    } else {
                        el.removeAttribute(k);
                    }
                }
            }

            // set new/changed props
            for (let [k, v] of Object.entries(newVNode.props)) {
                if (k.startsWith("on") && typeof v === "function") {
                    if (oldVNode.props[k] !== v) {
                        el[k.toLowerCase()] = v;
                    }
                    continue;
                }

                if (k === "className") {
                    if (oldVNode.props[k] !== v) {
                        el.setAttribute("class", v);
                    }
                    continue;
                }

                if (v === true) {
                    el.setAttribute(k, "");
                } else if (v === false || v == null) {
                    el.removeAttribute(k);
                } else if (oldVNode.props[k] !== v) {
                    el[k] = v;
                }
            }

            patchChildren(el, oldVNode.children, newVNode.children);
        }

        function render(component, parent) {
            const newVNode = component();

            if (!parent._vnode) {
                parent._vnode = newVNode;
                parent._component = component;
                parent.appendChild(newVNode.node());
                return;
            }

            patch(parent._vnode, newVNode, parent);
            parent._vnode = newVNode;
        }

        function notify(parent = document.getElementById("app")) {
            render(parent._component, parent);
        }

        const tags = new Proxy({}, {
            get(_, name) {
                return (...args) => {
                    let props = {};
                    let children = [];
                    for (const a of args) {
                        if (a == null) continue;
                        if (
                            typeof a === "object" &&
                            !(a instanceof VNode) &&
                            !(a instanceof Node) &&
                            !Array.isArray(a)
                        ) {
                            props = { ...props, ...a };
                            continue;
                        }
                        if (typeof a === "string" || typeof a === "number") {
                            children.push(new TextVNode(a));
                            continue;
                        }
                        children.push(a);
                    }
                    return new VNode(name, props, children);
                };
            }
        });

        const props = new Proxy({}, {
            get(_, key) {
                return (strings, ...values) => {
                    if (strings.length === 1 && strings[0] === "" && values.length === 0) {
                        return { [key]: true };
                    }
                    const value = String.raw({ raw: strings }, ...values);
                    return { [key]: value };
                };
            }
        });

        const events = new Proxy({}, {
            get(_, key) {
                if (!key.startsWith("on")) throw new Error("Events must start with 'on'");
                return (fn) => ({ [key]: (e) => { let r = fn(e); notify(); return r } });
            }
        });

        global.erg0 = { VNode, TextVNode, tags, props, events, render, notify };
    })(typeof window !== "undefined" ? window : globalThis);
</script>

<style>
    * {
        font-size: 16px;
        box-sizing: border-box;
        margin: 0;
    }

    .divider {
        padding: 3px;
        grid-column: span 4;
        border-radius: 6px;
        background: #eee;
        text-align: center;
        color: #666;
        font-weight: bold;
    }

    #container {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-width: 720px;
        align-items: center;
        justify-content: center;
        padding: 16px;
    }

    .matrix {
        display: grid;
        gap: 16px;
        grid-template-columns: 1fr 1fr;
    }

    #container>* {
        width: 100%;
    }

    body {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .number {
        text-align: right;
    }

    .header {
        font-weight: bold;
        font-size: 18px;
        text-wrap: wrap;
        max-width: 24ch;
        overflow-wrap: anywhere;
        text-align: center;
    }

    .options {
        display: flex;
        flex-direction: row;
        gap: 16px;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    button {
        border-radius: 6px;
        border: 1px solid #eee;
        background: none;
        padding: 6px;
    }

    button:hover {
        cursor: pointer;
        background: #eee;
    }

    .table {
        align-content: start;
        display: grid;
        grid-template-columns: 1fr 5fr 3fr 1fr;
        gap: 6px;
        border: 1px solid #eee;
        border-radius: 12px;
        padding: 6px;
    }

    input[type="checkbox"] {
        width: 24px;
        height: 24px;
    }

    #summary {
        font-style: italic;
        white-space: pre-wrap;
        overflow-wrap: break-word;
        word-break: break-all;
    }
</style>

<script>
    const { render, notify, tags, props, events } = erg0
    const { p, div, pre, button, textarea, img, input, span } = tags
    const { id, rows, value, type, className, style, src, draggable, checked, title } = props
    const { onclick, onchange, ondragstart, ondragenter, ondragover, ondragleave, ondrop } = events

    class EasyMap extends Map {
        normalizeKey(key) {
            if (typeof key === "object" && key !== null) {
                return JSON.stringify(key, Object.keys(key).sort());
            }
            return key;
        }

        push(key, value) {
            const k = this.normalizeKey(key);
            if (!this.has(k)) this.set(k, []);
            this.get(k).push(...value);
        }

        increment(key, delta = 1) {
            this.set(k, (this.getKey(k) ?? 0) + delta);
        }

        getKey(key) {
            return this.get(this.normalizeKey(key));
        }

        write(key, value) {
            const k = this.normalizeKey(key)
            this.set(k, value)
        }
    }

    let data = {{.}}

    const categories = new EasyMap();

    categories.write({ Type: "впс", Name: "Кодима" }, "Кодима")
    categories.write({ Type: "віпс", Name: "Загнітків" }, "Кодима")
    categories.write({ Type: "віпс", Name: "Шершенці" }, "Кодима")
    categories.write({ Type: "впс", Name: "Станіславка" }, "Станіславка")
    categories.write({ Type: "віпс", Name: "Тимкове" }, "Станіславка")
    categories.write({ Type: "віпс", Name: "Чорна" }, "Станіславка")
    categories.write({ Type: "впс", Name: "Окни" }, "Окни")
    categories.write({ Type: "віпс", Name: "Ткаченкове" }, "Окни")
    categories.write({ Type: "віпс", Name: "Гулянка" }, "Окни")
    categories.write({ Type: "віпс", Name: "Новосеменівка" }, "Окни")
    categories.write({ Type: "впс", Name: "Великокомарівка" }, "Великокомарівка")
    categories.write({ Type: "віпс", Name: "Павлівка" }, "Великокомарівка")
    categories.write({ Type: "впс", Name: "Велика Михайлівка" }, "Велика Михайлівка")
    categories.write({ Type: "віпс", Name: "Слов’яносербка" }, "Велика Михайлівка")
    categories.write({ Type: "віпс", Name: "Гребеники" }, "Велика Михайлівка")
    categories.write({ Type: "впс", Name: "Степанівка" }, "Степанівка")
    categories.write({ Type: "віпс", Name: "Лучинське" }, "Степанівка")
    categories.write({ Type: "віпс", Name: "Кучурган" }, "Степанівка")
    categories.write({ Type: "віпс", Name: "Лиманське" }, "Степанівка")

    const sortedFiles = [...new Set(data.map((event) => event.Filename))].sort()

    const files = new Map(sortedFiles.map((filename, index) => [filename, index == 0 ? 18 : 0]))

    document.addEventListener(
        "DOMContentLoaded",
        function () {
            const app = document.getElementById('app')

            render(App, app)
        }
    )

    function App() {
        const filtered = data.filter((e) => {
            return e.End > files.get(e.Filename)
        })

        const known = new EasyMap();

        const other = new EasyMap();

        const comments = new EasyMap();

        for (let event of filtered) {
            let key = { Type: event.Type, Name: event.Name }

            let target = known

            let category = categories.getKey(key)

            if (!category) {
                target = other
                key.Hint = event.Hint
            }

            target.push(key, [{ End: event.End, Comment: event.Comment }])
            event.Comment && comments.push(key, [{ Comment: event.Comment }])
        }

        let groups = new EasyMap();

        categories.forEach((category, key) => {
            let events = known.getKey(key)
            const sum = events ? events.length : 0
            groups.push(category, [{ ...JSON.parse(key), sum }])
        })

        let out = []

        groups.forEach((rows, category) => {
            let processed = rows.map((r) => Row(r))

            out.push(Table([Divider(category), ...processed]))
        })

        let out2 = [Divider("Інші")]

        other.forEach((rows, key) => {
            out2.push(Row({ ...JSON.parse(key), sum: rows.length }))
        })

        // sort???
        let fileSection = [Divider("Файли")]

        // allow disabled

        files.forEach((cutoff, filename) => {
            fileSection.push(
                div(style`grid-column: span 2; overflow-wrap: break-word;`, filename),
                input(
                    type`checkbox`,
                    cutoff === 18 ? checked`` : null,
                    onchange(e => files.set(filename, cutoff === 18 ? 0 : 18))
                ),
                div(className`number`, cutoff),
            )
        })

        const cases = new EasyMap();

        let commentsSection = []

        comments.forEach((events, key) => {
            let currentCases = 0
            let totalNumbers = 0

            let c = events.map((event) => {
                let numbers = 0
                let tokens = tokenize(event.Comment)
                for (let token of tokens) {
                    if (token.type === "text") {
                        continue
                    }

                    numbers += Number(token.number)
                }

                totalNumbers += numbers
                numbers > 0 && currentCases++

                return tokens.map(t => t.type === "text" ? t.value : Action(t.value))
            })

            let cat = categories.get(key)

            // TODO: cat???
            currentCases > 0 && cases.set(cat, { currentCases, totalNumbers })

            k = JSON.parse(key)
            commentsSection.push(Divider([k.Type, k.Name, k.Hint, `(${cat})`].filter(Boolean).join(" ")))
            commentsSection.push(c.map(tokenized => div(style`grid-column: span 4`, ...tokenized)))
        })

        let summary = ""

        let i = 0

        let casesText = Plural("випадку", "випадках", "випадках")
        let numbersText = Plural("порушення", "порушення", "порушень")
        let flightsText = Plural("політ", "польоти", "польотів")

        groups.forEach((group, key) => {
            i++

            let total = group.reduce((total, group) => { return total + group.sum }, 0)

            summary += `${i}. ${key} - ${flightsText(total)}`

            let currentCases = cases.get(key)
            if (currentCases) {
                summary += `, в ${casesText(currentCases.currentCases)} - ${numbersText(currentCases.totalNumbers)};`
            } else {
                summary += `, ОПДК не виявлено;`
            }
            summary += "\n"
        })

        return div(
            id`container`,
            img(
                style`width: 36px; height: 36px`,
                src`https://upload.wikimedia.org/wikipedia/commons/8/8d/Emblem_of_the_State_Border_Guard_Service_of_Ukraine.svg`,
            ),
            Table(fileSection),
            Matrix(out),
            Table(out2),
            Table(commentsSection),
            Table([div(id`summary`, style`grid-column: span 4;`, summary)]),
            div(className`options`,
                button("Скопіювати",
                    onclick(e => {
                        navigator.clipboard.writeText(document.getElementById('summary').innerText)
                        alert('Скопійовано!')
                    }, !notify)
                ),
                button("Поділитися",
                    onclick(e => {
                        navigator.share({ text: document.getElementById('summary').innerText })
                    }, !notify)
                ),
            ),
        )
    }

    function Action() {
        return span(
            style`cursor:pointer; font-weight: bold; background: #eee; border: 1px solid #ddd; padding: 0 6px; border-radius: 8px;`,
            ...arguments,
        )
    }

    function Row(row) {
        let out = []

        const cells = [
            { value: row.Type, span: 1 },
            { value: row.Name, span: 1 },
            { value: row.Hint, span: 1 },
        ]

        calculateSpans(cells)

        for (const component of cells) {
            component.value && out.push(
                div(
                    style`grid-column: span ${component.span};`,
                    title`${row.Hint}`,
                    component.value,
                )
            )
        }

        out.push(div(className`number`, row.sum))

        return out
    }

    function Divider(text) {
        return div(className`divider`, text)
    }

    function NumberCell(n) {
        return div(
            className`number`,
            style`grid-column: span 4; font-weight:bold`,
            n,
        )
    }

    function Table(elements) {
        return div(className`table`, ...elements)
    }

    function Matrix(elements) {
        return div(className`matrix`, ...elements)
    }

    function calculateSpans(items) {
        let last = -1
        let span = 0

        for (let i = 0; i < items.length + 1; i++) {
            if (items[last] && items[last].value) {
                items[last].span += span
                span = 0
            }

            if (items[i] && items[i].value) {
                last = i
                continue
            }


            span++
        }
    }

    function Plural(one, few, many) {
        return function (n) {
            const mod10 = n % 10;
            const mod100 = n % 100;

            let out = many;

            if (mod10 === 1 && mod100 !== 11) {
                out = one;
            } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
                out = few;
            }

            return `${n} ${out}`;
        };
    }

    function tokenize(str) {
        const re = /(\d+)\s*гр./g;
        const tokens = [];
        let lastIndex = 0;

        for (const m of str.matchAll(re)) {
            // push text before match
            if (m.index > lastIndex) {
                tokens.push({ type: "text", value: str.slice(lastIndex, m.index) });
            }

            // push the match itself
            tokens.push({
                type: "pieces",
                value: m[0],   // e.g. "123 pieces"
                number: m[1]  // just "123"
            });

            lastIndex = m.index + m[0].length;
        }

        // push any trailing text
        if (lastIndex < str.length) {
            tokens.push({ type: "text", value: str.slice(lastIndex) });
        }

        return tokens
    }
</script>

<div id="app">

</div>